---
layout:     post
title:     机器学习：决策树分类模型
subtitle:   Decision tree
date:       2018-12-04
author:     粘世强
header-img: img/staircase.jpg
catalog: true
tags:
    - machine learning
---


## 1.分类决策树介绍：

决策树是树模型的基础形式。它包含一个根节点，若干个内部节点，以及若干个叶子节点。其中根节点包含全部的样本。每个内部节点代表了一个属性测试，每个子节点对应于一个决策结果（分为多少类就有多少个子节点）。决策树学习的目的在于产生一颗泛化能力强的决策树。

决策树的优点：(1):直观易理解，符合人认知事物的过程。(2)应用范围广，分类回归均可以。缺点就是容易造成过拟合。需要剪枝来适当限制。一般还会通过限制树的高度，或者叶子节点上样本的数量来防止过拟合。

## 2.决策树停止的三种情况：

* 当前节点所包含的所有样本都属于同一类，无需再划分。
* 当前节点上所有属性的值都相同，不能再划分。此时将 类别设置为当前节点上所含样本最多的类别。
* 当前节点包含的样本集为空，无法划分。此时将类别设置为当前节点父节点上所含样本最多的类别。

## 3.划分方法

依照划分方法的不同，分为三种算法，ID3,C4.5,CART。根本问题在于如何选择最优的划分属性。进一步理解就是说经过这个节点划分后的节点纯度达到最高。

### 3.1 ID3算法

该算法依据信息增益计算。

信息熵计算：$ Ent(D)=-\sum_{k=1}^{y}p_klog_2p_k$

<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;Ent(D)=-\sum_{k=1}^{y}p_klog_2p_k" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;Ent(D)=-\sum_{k=1}^{y}p_klog_2p_k" title="Ent(D)=-\sum_{k=1}^{y}p_klog_2p_k" /></a>

其中p_k代表当前样本中第k类样本所占的比例。Ent(D)的值越小，则D的**纯度越高**。



假设利用属性a进行分类，a有v个分支节点。其中每个分支节点上的样本数目为$D^v$。这样就可以在每个分支节点上计算出信息熵。然后给每个分支节点赋予权重$\frac{D^v}{D}$，即节点上样本数目越多，则该节点的权重越大。这样就可以得到划分后的信息熵

$\sum_{v=1}^{V}\frac{D^v}{D}Ent(D^v)$

<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" title="\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" /></a>。

接下来即可计算信息增益：

$Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{D^v}{D}Ent(D^v)$

<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" title="Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)" /></a>

一般而言，信息增益越大，则意味着使用该节点划分后所获得的“纯度提升越大”。

综上所述，ID3算法以信息增益为准则来选择划分属性。哪个属性划分后，信息熵最小，所获得得信息增益越高，样本纯度越高，则选择哪个属性。

信息增益准则的缺陷：

* 对可取得数目较多的属性有所偏好。这个可以这样理解，一个属性的可取值数目越多，则根据该属性划分后每个节点上的样本数目也就越少，样本纯度也就越高。因此带来的信息增益也就越高，因此按照信息增益准则来划分时，可取值数目较多的样本更容易受到青睐。
* 不能处理特征值为连续的情况。
* 本身是一种贪心算法，只关心当前阶段达到最优，不关心全局最优。
* 每次根据“信息增益最大准则”来选取特征进行切分，并且按照特征的所有值进行切分，也就是说如果该特征有4个取值，那么就将数据集切分为4份。使用过的特征就不再使用。

### 3.2 C4.5算法

鉴于ID3算法的缺陷，为了减少这种偏好对结果的影响，有了C4.5算法。该算法不直接使用信息增益来进行划分特征的选择，而是采用"增益率"来选择。具体计算公式：



$Gain_-ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$

<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;Gain_-ratio(D,a)=\frac{Gain(D,a)}{IV(a)}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;Gain_-ratio(D,a)=\frac{Gain(D,a)}{IV(a)}" title="Gain_-ratio(D,a)=\frac{Gain(D,a)}{IV(a)}" /></a>

其中$IV(a)=-\sum_{v=1}^{V}\frac{D^v}{D}log_2\frac{D^v}{D}$

<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}" title="IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}" /></a>



在公式中$IV(a)$称为a特征的固有值。如果a特征可能取值的数目越多，则$IV(a)$越大。这样一来，当某个特征的可取值数目较多时，它所获得的信息增益会变大，与此同时，它的特征固有值也会变大。因此通过这种方法可以避免ID3算法的不足。

需要注意的是，增益率准则对可取值数目较少的算法有偏好。因此,C4.5算法选择了一种启发式算法，先从候选划分特征中选出信息增益水平高于平均水平的属性（可以理解为“去尾”，去掉可取值比较少的属性），然后再从这些属性中选择增益率最高的属性(可以李解为“掐尖”，去掉可取值比较多的属性)。

### 3.3 CART算法

该算法采用‘基尼系数’来选择划分属性。

数据集D的纯度：$Gini(D)=1-\sum_{k=1}^{y}p_k^2​$
<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_cm&space;Gini(D)=1-\sum_{k=1}^{y}p_k^2" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;Gini(D)=1-\sum_{k=1}^{y}p_k^2" title="Gini(D)=1-\sum_{k=1}^{y}p_k^2" /></a>

属性a的基尼指数：$Gini_-index=\sum_{v=1}^{V}\frac{D^v}{D}Gini(D^v)$

直观来看，这个系数反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率。因此，该系数越小，表明数据集纯度越高。于是，该算法选择那个使得划分后基尼指数最小的属性作为划分属性。

同时需要说明的是，CART算法得到的决策树是一个二叉树，，每次划分时都只分出两个叶子节点。这样对于取值大于2的特征，则会进行特征组合，以达到两类。如某特征值具有[‘young’,’middle’,’old’]三个取值,那么二分序列会有如下3种可能性(空集和满集在CART分类中没有意义): 
[((‘young’,), (‘middle’, ‘old’)), ((‘middle’,), (‘young’, ‘old’)), ((‘old’,), (‘young’, ‘middle’))] 
采用CART算法，就需要分别计算按照上述List中的二分序列做分叉时的Gini指数，然后选取产生最小的Gini_index的二分序列做该特征的分叉二值序列参与树构建的递归。

## 4.决策树剪枝

剪枝是用来防止决策树过拟合的主要手段。决策树在生成过程中，节点不断划分，有时会造成决策树分支过多，这样会导致把训练集自身的一些特点当作所有数据的特点而产生过拟合现象。决策树剪枝方式有两种：“预剪枝”和“后剪枝”。

### 4.1预剪枝

预剪枝是指在决策树生成过程中，对每个节点在划分前后进行判断，如果划分后不能带来决策树**泛化性能**的提升，则停止剪枝，将当前节点标记为叶子节点。

具体方法：在划分前，将验证集上的数据按照决策树进行运算，计算划分前这棵树在验证集上的准确率。然后进行划分，得到划分后的决策树，然后再在验证集上计算准确率，如果准确率有提升，则进行划分；若无提升，则不进行划分。   

优缺点：从剪枝方法上可以看出，预剪枝使得很多分支都没有展开，这当然降低了过拟合的风险，而且还能显著的降低训练时间。但是从另一方面来讲，有可能存在以下情况，有些分支的当前划分虽不能提高泛化性能，但是在其基础上进行的后续划分却有可能导致模型泛化性能的显著提升，。因此，预剪枝这种’贪心‘的算法，使得模型有了欠拟合的风险。          

### 4.2后剪枝                                                                                                                                                    

后剪枝是指首先生成一棵完整的决策树，然后自底向上的对非叶子结点进行考察，如果将该节点对应的子树替换为叶子节点，模型的泛化能力有提高，则将该子树剪掉，替换为叶子节点。

具体方法：首先从训练集生成一棵完整的决策树。然后从下往上考察每个分支，如果将该分支替换为叶子节点后，模型在验证集上的精度有提高，则将该节点替换为叶子节点，否则就不进行替换。

优缺点：这种方法比预剪枝保留了更多的分支，因此欠拟合的风险较小。但是，这种方法是在生成完全决策树之后进行，而且要自底向上对**所有非叶子结点**进行逐一考察，训练所用时间比预剪枝要大得多。

## 5.连续值处理

连续值的处理思路（C4.5算法）如下：

假设一个特征a在数据集D上是连续的，有n个取值。

1. 将这n个取值从小到大排列，然后取出相邻两个值的平均值作为候选划分点，这样就会有n-1个候选划分点。

2. 根据每个划分点，将数据分成两组，即小于该划分点的数据和大于该划分点的数据。

3. 分别计算经过每个划分点划分后的信息增益，选出信息增益最大的划分点，作为该特征的划分点。

**需要注意的是：与离散属性不同，若当前节点划分属性为连续属性，则该属性还可作为后续节点的划分属性。**

## 6.缺失值处理

缺失值的处理思路（C4.5算法）如下：

对于存在缺失值的特征，取出其中所有非缺失的样本。假设一个数据集D有n个样本，特征a中有m个样本缺失，该特征中有n-m个样本非缺失。将这n-m个样本组成样本子集D'，计算该样本子集在特征a上的信息增益Gain(D',a),然后将该信息增益乘(n-m)/n,得到样本集D在特征a上的信息增益。

**注意**：连续值和缺失值在处理过程中均是计算信息增益，而不是信息增益率。只有在特征选择中，才使用信息增益率。

## 参考资料

1. 周志华老师的《机器学习》
2. https://www.cnblogs.com/wxquare/p/5379970.html

